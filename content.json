{"pages":[{"title":"google7c9c794a9b10a10f","text":"google-site-verification: google7c9c794a9b10a10f.html","link":"/google7c9c794a9b10a10f.html"},{"title":"404","text":"404","link":"/404.html"}],"posts":[{"title":"Docker入门","text":"1 Docker简介1.1 什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 ​ 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 1.4 Docker 组件1.4.1 Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 1.4.3 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。https://hub.docker.com/ 2 Docker安装与启动2.1 安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 （1）yum 包更新到最新 1sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker 1sudo yum install docker-ce （5）安装后查看docker版本 1docker -v 2.2 设置ustc的镜像​ ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： 1vi /etc/docker/daemon.json 在该文件中输入如下内容： 123{ &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]} 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 查看docker状态： 1systemctl status docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 3 常用命令3.1 镜像相关命令3.1.1 查看镜像1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi `docker images -q` 3.2 容器相关命令3.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 3.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 3.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 3.2.5 目录挂载​ 我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。​ 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 ​ 如果你共享的是多级的目录，可能会出现权限不足的提示。 ​ 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID） 3.2.7 删除容器删除指定的容器： 1docker rm 容器名称（容器ID） 4 应用部署4.1 MySQL部署（1）拉取mysql镜像 1docker pull centos/mysql-57-centos7 （2）创建容器 1docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP,指定端口为33306 4.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 4.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name=mynginx -p 80:80 nginx 4.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name=myredis -p 6379:6379 redis 5 迁移与备份5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 6 Dockerfile6.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 6.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER XUKUN#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t='jdk1.8' . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images 7 Docker私有仓库7.1 私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]} 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1{&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]} 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 1docker push 192.168.184.141:5000/jdk1.8 8 DockerMaven插件8.1 微服务部署有两种方法：（1）手动部署：首先基于源码打包生成jar包（或war包）,将jar包（或war包）上传至虚拟机并拷贝至JDK容器。 （2）通过Maven插件自动部署。 ​ 对于数量众多的微服务，手动部署无疑是非常麻烦的做法，并且容易出错。所以我们这里学习如何自动部署，这也是企业实际开发中经常使用的方法。 8.2 Maven插件自动部署步骤：（1）修改宿主机的docker配置，让其可以远程访问 1vi /lib/systemd/system/docker.service 其中ExecStart=后添加配置 1‐H tcp://0.0.0.0:2375 ‐H unix:///var/run/docker.sock 修改后如下： （2）刷新配置，重启服务 123systemctl daemon‐reloadsystemctl restart dockerdocker start registry （3）在工程pom.xml 增加配置 123456789101112131415161718192021222324252627282930&lt;build&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐maven‐plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!‐‐ docker的maven插件，官网：https://github.com/spotify/docker‐maven‐plugin ‐‐&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker‐maven‐plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;192.168.184.141:5000/${project.artifactId}:${project.version} &lt;/imageName&gt; &lt;baseImage&gt;jdk1.8&lt;/baseImage&gt; &lt;entryPoint&gt;[&quot;java&quot;, &quot;‐jar&quot;, &quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory} &lt;/directory&gt; &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;dockerHost&gt;http://192.168.184.141:2375&lt;/dockerHost&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 以上配置会自动生成Dockerfile 123FROM jdk1.8ADD app.jar /ENTRYPOINT [&quot;java&quot;,&quot;‐jar&quot;,&quot;/app.jar&quot;] （5）在windows的命令提示符下，进入工程tensquare_parent所在的目录 1mvn install 进入tensquare_base 所在的目录，输入以下命令，进行打包和上传镜像 1mvn docker:build ‐DpushImage 执行后，会有如下输出，代码正在上传 （6）进入宿主机 , 查看镜像 1docker images 1234REPOSITORY TAG IMAGE ID CREATED SIZE192.168.184.135:5000/tensquare_base 1.0‐SNAPSHOT 83efa6b4478c 10 minutes ago 687.9 MB192.168.184.135:5000/jdk1.8 latest 507438a0158f 6 hours ago 584 MBjdk1.8 latest 507438a0158f 6 hours ago 584 MB 输出如上内容，表示微服务已经做成镜像浏览器访问 http://192.168.184.141:5000/v2/_catalog ，输出 1{&quot;repositories&quot;:[&quot;tensquare_base&quot;]} （7） 启动容器： 1docker run ‐di ‐‐name=base ‐p 9001:9001 192.168.184.141:5000/tensquare_base:1.0‐SNAPSHOT","link":"/2021-11-21/4ada93cc441a/"},{"title":"Hexo+Icarus+Github搭建个人博客","text":"Hexo+GitHub是一种低成本、快速搭个人博客的方案，本文主要简述我在搭建个人博客过程。 Hexo安装什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提安装 Hexo 相当简单，只需要先安装下列应用程序即可： Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) Git并配置好Github ssh免密登录 开始安装所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo，在需要安装的目录打开nodejs控制台输入以下命令： 12345npm install -g hexo-clihexo init blogcd blognpm installhexo server 经过这一顿操作，不出意外你的博客就已经在你本地启动起来了，控制台会输出一个网址http://localhost:4000/，在浏览器打开这个网址就能看见你的博客了。 Icarus快速上手Icarus是静态网站生成器Hexo的一款简单，精致，而现代的主题。 它力求设计上的优雅，但也不抛弃使用上的简单明了。 它灵活且多功能的配置系统让资深用户也能极尽细节地装饰他们的站点。 Icarus同时也提供了超多插件与挂件来满足你的多元的站点个性化和优化需求。 除此以外，它的崭新实现使得更好的IDE支持和第三方接入成为可能，并提供了更多未来的优化空间。 从源码安装下载主题源码 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b 4.4.0 --depth 1 使用hexo命令修改主题为Icarus 1hexo config theme icarus 最后，使用如下命令来启动Hexo本地测试服务器并开始创作。 12npm installhexo server 打开页面http://localhost:4000/，顺眼许多。 遇到的问题，缺少npm包 根据报错信息，安装所需npm包 1npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.13.0 inferno@^7.3.3 inferno-create-element@^7.3.3 Hexo及主题配置Hexo配置参考：https://hexo.io/zh-cn/docs/configuration.html Icarus主题配置参考：https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/ 部署到Github创建用户名同名的Github仓库，Github 仅能使用一个同名仓库的代码托管一个静态站点。 安装部署插件 1npm install hexo-deployer-git --save 配置_config.yml文件 1234deploy: type: 'git' repo: git@github.com:xukun0904/xukun0904.github.io.git branch: master 生成静态文件，并部署上传到Github 12hexo generatehexo deploy 之后访问你的用户名.github.io可以访问到你的个人博客了，Enjoy It 更多Hexo命令参考：https://hexo.io/zh-cn/docs/commands 跟过主题组件配置参考：https://ppoffice.github.io/hexo-theme-icarus/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/","link":"/2021-11-21/0077e93fe6de/"},{"title":"Mybatis-Plus分页查询数据重复","text":"问题描述​ 使用MyBatis-Plus 3.1.0，在做一个千万级数据从MySQL导入ElasticSearch的测试脚本中，由于数据量过大，不能一次获取，所以需要分页，循环递增页码来获取数据中发现每次分页查询结果都一样。 问题原因​ MyBatis 判断是否需要使用一级缓存的代码早于 MyBatis-Plus 分页插件拦截的代码执行，导致获取的结果一直都是一级缓存中的数据。 解决方案​ 在对应XML的SELECT标签中，加入flushCache=”true”属性，调用此查询方法会自动清除一级缓存和二级缓存。","link":"/2021-11-21/3c18081440f0/"},{"title":"MariaDB、JDK及Redis安装指南","text":"MariaDB安装与配置简介 MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。 安装准备 查看系统版本 12[root@xukun94 ~]# cat /etc/redhat-releaseCentOS Linux release 7.7.1908 (Core) 查看是否已经安装 1234[root@xukun94 ~]# rpm -qa | grep mariadbmariadb-libs-5.5.65-1.el7.x86_64mariadb-server-5.5.65-1.el7.x86_64mariadb-5.5.65-1.el7.x86_64 以上代表安装过，可卸载重装，卸载命令 1[root@xukun94 ~]# yum remove mariadb-server 开始安装通过yum安装即可，yum命令如下 1[root@xukun94 ~]# yum install mariadb-server 启动服务 1[root@xukun94 ~]# systemctl start mariadb 若需要开机自动启动，执行以下命令即可 1[root@xukun94 ~]# systemctl enable mariadb 配置首次配置 进行初始化配置 1[root@xukun94 ~]# mysql_secure_installation 配置过程如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we'll need the currentpassword for the root user. If you've just installed MariaDB, andyou haven't set the root password yet, the password will be blank,so you should just press enter here.# 输入数据库管理员密码，若第一次进入则直接回车Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.# 设置密码Set root password? [Y/n] y# 密码New password: # 确认密码Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.# 是否移除匿名用户Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from 'localhost'. Thisensures that someone cannot guess at the root password from the network.# 是否拒绝远程登录Disallow root login remotely? [Y/n] n ... skipping.By default, MariaDB comes with a database named 'test' that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.# 是否移除test测试数据库Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.# 是否重新加载权限库Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you've completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB! 测试是否能登录成功 1234567891011[root@xukun94 ~]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 10Server version: 5.5.65-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; 配置字符集为UTF-8 编辑/etc/my.cnf 文件 1[root@xukun94 ~]# vi /etc/my.cnf [mysqld]标签下添加如下代码 12345init_connect='SET collation_connection = utf8_unicode_ci'init_connect='SET NAMES utf8'character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshake 编辑/etc/my.cnf.d/client.cnf 文件，在[client]标签下添加 1default-character-set=utf8 编辑/etc/my.cnf.d/mysql-clients.cnf文件，在[mysql]标签下添加 1default-character-set=utf8 重启服务后生效 1[root@xukun94 ~]# systemctl restart mariadb 登录MariaDB，查看编码是否生效 123456789101112131415161718192021222324MariaDB [(none)]&gt; show variables like &quot;%character%&quot;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec)MariaDB [(none)]&gt; show variables like &quot;%collation%&quot;;+----------------------+-----------------+| Variable_name | Value |+----------------------+-----------------+| collation_connection | utf8_unicode_ci || collation_database | utf8_unicode_ci || collation_server | utf8_unicode_ci |+----------------------+-----------------+3 rows in set (0.00 sec) 修改防火墙，开启端口 123456789101112# 查看防火墙3306端口是否开启[root@xukun94 ~]# firewall-cmd --query-port=3306/tcpno# 开启防火墙3306端口[root@xukun94 ~]# firewall-cmd --zone=public --add-port=3306/tcp --permanentsuccess# 重启防火墙[root@xukun94 ~]# firewall-cmd --reloadsuccess# 查看防火墙3306端口是否开启[root@xukun94 ~]# firewall-cmd --query-port=3306/tcpyes 设置MariaDB可远程连接 查看mysql库中user表 12345678910111213141516MariaDB [(none)]&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; select host, user from user -&gt; ;+-----------+------+| host | user |+-----------+------+| 127.0.0.1 | root || ::1 | root || localhost | root || xukun94 | root |+-----------+------+4 rows in set (0.00 sec) 将host为当前主机名的记录，host属性修改成’%’ 123MariaDB [mysql]&gt; update user set host='%' where host='xukun94';Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 刷新权限表 12MariaDB [mysql]&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 远程连接配置完成，使用连接工具连接即可 JDK1.8安装与配置安装准备 查看系统位数 I386或I686 都是32位 x86_64 是 64位 12[root@xukun94 ~]# uname -aLinux xukun94 3.10.0-229.1.2.el7.x86_64 #1 SMP Fri Mar 27 03:04:26 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux 进入Oracle官网下载JDK1.8，选择对应系统位数的rpm下载 使用xftp6等传输工具将下载好的文件上传到远程服务器中 开始安装使用rpm命令安装 1[root@xukun94 ~]# rpm -ivh jdk-8u261-linux-x64.rpm 配置添加环境变量，编辑source /etc/profile文件 1[root@xukun94 ~]# vi /etc/profile 在此文件最后添加如下代码 12export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH 生效环境变量 1[root@xukun94 ~]# source /etc/profile 查看jdk是否安装成功 1234[root@xukun94 ~]# java -versionjava version &quot;1.8.0_261&quot;Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode) Redis安装与配置安装准备 使用wget命令下载Redis5.0.9 1[root@xukun94 ~]# wget http://download.redis.io/releases/redis-5.0.9.tar.gzwget http://download.redis.io/releases/redis-5.0.9.tar.gz 解压 1[root@xukun94 ~]# tar xzf redis-5.0.9.tar.gz 开始安装 进入解压后文件夹，执行make编译命令 12[root@xukun94 ~]# cd redis-5.0.9[root@xukun94 redis-5.0.9]# make 若遇到一下错误，说明gcc未安装，使用yum命令安装即可 123456789101112131415MAKE hirediscd hiredis &amp;&amp; make staticmake[3]: Entering directory `/root/redis-5.0.9/deps/hiredis'gcc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb net.cmake[3]: gcc: Command not foundmake[3]: *** [net.o] Error 127make[3]: Leaving directory `/root/redis-5.0.9/deps/hiredis'make[2]: *** [hiredis] Error 2make[2]: Leaving directory `/root/redis-5.0.9/deps'make[1]: [persist-settings] Error 2 (ignored) CC adlist.o/bin/sh: cc: command not foundmake[1]: *** [adlist.o] Error 127make[1]: Leaving directory `/root/redis-5.0.9/src'make: *** [all] Error 2 yum安装gcc 1[root@xukun94 redis-5.0.9]# yum install gcc 再次运行make编译命令，可能遇到以下错误 1234567891011121314cd src &amp;&amp; make allmake[1]: Entering directory `/root/redis-5.0.9/src' CC Makefile.depmake[1]: Leaving directory `/root/redis-5.0.9/src'make[1]: Entering directory `/root/redis-5.0.9/src' CC adlist.oIn file included from adlist.c:34:0:zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory #include &lt;jemalloc/jemalloc.h&gt; ^compilation terminated.make[1]: *** [adlist.o] Error 1make[1]: Leaving directory `/root/redis-5.0.9/src'make: *** [all] Error 2 执行以下代码进行编译 1[root@xukun94 redis-5.0.9]# make MALLOC=libc 没有错误后，安装命令 1[root@xukun94 redis-5.0.9]# make install 配置 编辑redis.conf文件 1[root@xukun94 redis-5.0.9]# vi redis.conf 修改以下配置 1234# redis后台运行daemonize yes# 添加ipbind 127.0.0.1 192.168.136.128 允许远程访问redis 123456789101112# 查看防火墙6379端口是否开启[root@xukun94 redis-5.0.9]# firewall-cmd --query-port=6379/tcpno# 开启防火墙6379端口[root@xukun94 redis-5.0.9]# firewall-cmd --zone=public --add-port=6379/tcp --permanentsuccess# 重启防火墙[root@xukun94 redis-5.0.9]# firewall-cmd --reloadsuccess# 再次查看防火墙6379端口是否开启[root@xukun94 redis-5.0.9]# firewall-cmd --query-port=6379/tcpyes 启动redis 1[root@xukun94 redis-5.0.9]# redis-server redis.conf 登录redis，验证是否安装成功 12[root@xukun94 redis-5.0.9]# redis-cli127.0.0.1:6379&gt; exit 关闭服务器 1[root@xukun94 redis-5.0.9]# redis-cli shutdown","link":"/2021-11-21/f01fc1ab108a/"},{"title":"Shiro修改角色权限没有生效","text":"问题描述​ 使用Shiro中shiro:hasPermission标签，修改角色权限后相同角色下各个用户权限不一致问题。在角色管理中修改当前登陆人的角色权限，当前用户的权限更新了，但是这个角色下其它用户的权限还是修改前的权限。 问题原因​ shiro:hasPermission进行比较权限时，先通过CacheManager获取了Redis中的当前用户的权限缓存。 ​ 而更新角色权限后，调用Realm中的内置的clearCache方法清除权限缓存，只清除了当前用户的权限缓存。 解决方案​ 需要清除该角色下所有用户的权限缓存，通过RedisSessionDAO获取所有用户信息，然后循环清除用户权限缓存。若需要清除指定用户权限缓存，可将SimplePrincipalCollection对象强转成用户对象，再根据传入用户主键集合判断是否需要清除权限缓存。","link":"/2021-11-21/e66b8f2cdbc7/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","link":"/tags/MyBatis-Plus/"},{"name":"MariaDB","slug":"MariaDB","link":"/tags/MariaDB/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Shiro","slug":"Shiro","link":"/tags/Shiro/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"工具安装","slug":"工具安装","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"},{"name":"日常随笔","slug":"日常随笔","link":"/categories/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"},{"name":"云原生","slug":"学习笔记/云原生","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%91%E5%8E%9F%E7%94%9F/"},{"name":"前端","slug":"工具安装/前端","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/%E5%89%8D%E7%AB%AF/"},{"name":"问题记录","slug":"日常随笔/问题记录","link":"/categories/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"后端","slug":"工具安装/后端","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/%E5%90%8E%E7%AB%AF/"}]}